# Set up notebook
## Load libraries & functions
```{r}
source("libraries.R")
source("functions.R")

library(radish)
library(raster)
library(igraph)

```

## Load data
### surface created on the cluster
```{r}
load("~/R_Projects/chapter_three/surface2.RData")
```

### Raster data (LULC)
```{r}
solris_raster <- raster::raster(here::here("./raw_data/SOLRIS_Version_3_0/SOLRIS_Version_3_0_LAMBERT.tif"))


# inspect
# print(solris_raster)
# plot(solris_raster)

# crop raster
gta_solris <- raster::crop(solris_raster,
                    extent(1285000, # xmin
                           1450000, # xmax
                           11840000, # ymin
                           11970000)) # ymax


# check classes not warped
# unique(gta_solris)

rm(solris_raster)

# get resolution: 15x15
res(gta_solris)

# change res to 75x75

# this changes the cell values- can't have that
# gta_solris <- raster::aggregate(gta_solris,
#                             fact=5)

# Create an empty raster with the desired 75x75 resolution
new_resolution <- 75
new_raster <- raster(extent(gta_solris),
                     res = c(new_resolution,
                             new_resolution))
projection(new_raster) <- projection(gta_solris)

test <- resample(gta_solris, 
                 new_raster,
                 method = "ngb")

res(test)
plot(test)

gta_solris <- test

res(gta_solris)



# Add LULC classes to raster
# gta_classes <- unique(gta_solris)
# 
# print(gta_classes)
# 
# # took these labels from 'Southern Ontario Land Resource Information System Version 3.0 Data Specifications.pdf'
# lulc_labels <- c("Open Beach",
#                    "Treed Sand Dune",
#                    "Open Cliff and Talus",
#                    "Treed Cliff and Talus",
#                    "Shrub Alvar",
#                    "Open Tallgrass Prairie",
#                    "Tallgrass Savannah",
#                    "Tallgrass Woodland",
#                    "Forest",
#                    "Coniferous Forest",
#                    "Mixed Forest",
#                    "Deciduous Forest",
#                    "Treed Swamp",
#                    "Thicket Swamp",
#                    "Fen",
#                    "Bog",
#                    "Marsh",
#                    "Open Water",
#                    "Plantation",
#                    "Hedge Rows",
#                    "Tilled",
#                    "Transportation",
#                    "Built Up Area- Pervious",
#                    "Built Up Area- Impervious",
#                    "Extraction- Aggregate",
#                    "Extraction- Peat/Topsoil",
#                    "Undifferentiated")
# 
# reclass_matrix <- cbind(gta_classes,
#                         lulc_labels)
# 
# 
# # convert numeric values into factor classes
# gta_solris <- as.factor(gta_solris)
# 
# # get data class IDs for LULCs
# gta_solris@data@attributes # same as: levels(gta_solris)
# 
# 
# # Convert the attribute table to a data frame
# attr_df <- as.data.frame(gta_solris@data@attributes)
# 
# 
# # Join the attribute data frame with the land_cover_id_list
# attr_df <- cbind(attr_df,
#                  as.data.frame(lulc_labels))
# 
# 
# gta_solris@data@attributes[[1]] <- attr_df
# 
# # Print the updated raster
# print(gta_solris)

```


### Genetic data
```{r}
# format required: genetic distances

# vcf
vcf <- read.vcfR(
  here::here("./summary_stats/output_populations_no-IBD/mmaf0.05_R0.75/populations.snps.vcf"),
  verbose = FALSE)

## Convert vcf to genind object
my_genind <- vcfR2genind(vcf)

# tidy up colnames (remove periods)
inputdata1 <- my_genind$tab

genetic_distance_matrix <- poppr::prevosti.dist(my_genind)

```


### Geographic sampling coordinates
#### import coords
```{r}
# lat/longs of sampling sites
urb <- read.csv(here::here("./clean_data/urb_metrics.csv"))

# sampling site IDs and genetic sample names
coords <- read.csv(here("./genomic_resources/pop_map3.csv")) %>%

# if population doesn't start with "MWI", it should start with "MW"
  # rename col 1
  dplyr::rename(pop_id = 2) %>%
  dplyr::mutate(pop_id = as.factor(pop_id)) %>%

# take entries with numeric populations and add "MW" as prefix
  add_MW_IDs() %>%

# left vs. full join because some populations in urb_clean weren't genotyped due to lack of material
  left_join(., urb, by = "patch_id") %>%
  dplyr::mutate(patch_id = as.factor(patch_id),
                pop_id = as.factor(pop_id)) %>%
  dplyr::select(c(1,2,6,7)) %>%
  dplyr::rename("y" = 3,
                "x" = 4) %>%
  dplyr::arrange(sample) %>%
  dplyr::select("x", "y")

```

#### convert to correct proj/cs
```{r}

# Convert the dataframe to a SpatialPoints object
sp_points <- SpatialPoints(coords, 
                           proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs"))

# Project the SpatialPoints object to match the raster's CRS
sp_points_proj <- spTransform(sp_points, crs(gta_solris))

# convert to spatialpoints obj
sp_points_proj <- SpatialPoints(sp_points_proj, 
                           proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs"))

# Plot the raster
plot(gta_solris)

# Overlay the projected SpatialPoints on the raster
points(sp_points_proj, col = "red", pch = 20)
```


## Fit radish models
```{r}
fit_mlpe <- radish(genetic_distance_matrix ~ gta_solris,
                   data = surface, 
                   conductance_model = radish::loglinear_conductance, 
                   measurement_model = radish::mlpe)

# examine model
print(summary(fit_mlpe))

## we are modeling conductances --> positive coefficient estimates indicate increasing conductance (e.g. rates of movement/gene flow) at higher values of the covariate, while negative coefficients indicate lower conductance at higher values of the covariate.


## Plot fitted conductance surface
fitted_conductance <- conductance(surface,
                                  fit_mlpe,
                                  quantile = 0.95)

plot(log(fitted_conductance[["est"]]), 
     main = "Fitted conductance surface")

```

# Export conductance surface
```{r}

pdf("conductance_surface.pdf",         # File name
    width = 8, height = 7, # Width and height in inches
    bg = "white",          # Background color
    colormodel = "cmyk" ,   # Color model (cmyk is required for most publications)
    paper = "A4")          # Paper size

# Creating a plot
plot(log(fitted_conductance[["est"]]), 
     main = "Fitted conductance surface")

# Closing the graphical device
dev.off() 
```
